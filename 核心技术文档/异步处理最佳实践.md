# 异步处理最佳实践

> 这份文档记录我第一次用 RxJava3 + MVVM 做客户端的摸索过程：从“能跑”到“顺畅、安全、可维护”。很多思路来自 vibe coding 的对话式试错。



## 踩到的坑

- 在 View 里直接开线程/持有 Disposable，页面退出后还在跑，差点导致内存泄漏。
- 网络、数据库混在主线程调用，偶发卡顿。
- 错误提示零散，多个 Fragment 重复写 try/catch。



## 调整后的约定（落地）

- **统一调度**：网络/库全部 `subscribeOn(Schedulers.io())`，UI 更新前 `observeOn(AndroidSchedulers.mainThread())`。
- **集中管理**：所有 Disposable 只放在 ViewModel，用 `CompositeDisposable`，`onCleared()` 统一清理；Fragment/Activity 只订阅 LiveData。
- **单点副作用**：把成功/失败处理收敛到 `handleSuccess/handleError`，避免匿名回调到处散落。
- **友好反馈**：长耗时时设置 `isGenerating`，UI 显示进度/禁用按钮；错误通过 `toastEvent` 统一弹出。



## 典型链路（实践版）

- **发送消息**：构造 ChatRequest → `apiService.sendMessage` → IO 线程跑网络 → 主线程更新消息列表/状态 → 失败统一落 `handleError`。
- **历史/对话图谱预填**：Repository 在 IO 拉取消息 → 主线程拼装“用户/AI”带前缀的整段文本 → LiveData 推给 ChatFragment 自动填入输入框。



## 得到的启发

- “线程调度写清楚”比“到处 try/catch”更重要；清晰的链路更好 debug。
- View 不要管 Disposable，交给 ViewModel；否则很容易忘记取消。
- 把提示文案和 Loading 状态集中管理，UX 会自然好很多。

## 还想做的事
- 把主线程的 Room 访问迁移到 IO，并为历史列表接入 Paging3。
- 如果后续需要并行多个请求，用 `Single.zip` 等组合算子，减少嵌套。
- 如改用 Kotlin，可平滑迁移到 Coroutine + Flow，但当前 Java + RxJava3 已够用。

