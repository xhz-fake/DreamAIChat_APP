# 数据存储最佳实践

> 这是我把“差点把历史聊天全删光”的坑填平的记录，也是第一次在 Room/SharedPreferences 上形成自己的习惯清单。

## 事故回顾
- 登录后重登，历史记录全没了，但用户名还在。  
  - 溯源：UserDao 的 `REPLACE` 触发外键级联，删掉了用户关联的会话与消息；用户名还在是因为 SessionManager 没清除。
- 数据库升级险些“自毁”：`fallbackToDestructiveMigration()` 会在 schema 变更时直接清库。



## 我们的修复与做法

- **用户插入策略**：登录时先查 account 是否存在，存在则更新，不存在再插入，避免 REPLACE 触发级联删除。
- **保留展示信息**：SessionManager.clear 不清除 account/displayName，方便下次登录显示；但 token/userId 会清掉。
- **禁止暴力删库**：移除 `fallbackToDestructiveMigration()`，后续如需升级必须写 Migration。
- **外键绑定修正**：提供 `updateUserIdForAllConversations` 把演示态的 `-1` userId 绑定到真实用户，防止“孤儿会话”。



## 当前结构

- Room 三表：User / Conversation / Message，外键级联保证数据一致性。
- SharedPreferences：存 token/userId/account/displayName，用于会话归属与展示。
- LiveData/ViewModel：短期内存态，页面内的数据呈现。



## 现阶段的最佳实践（贴合本项目）

- DAO 冲突策略：能 UPDATE 就不要 REPLACE；需要 upsert 时先查再更。
- 主线程访问：Demo 期保留 `allowMainThreadQueries()` 方便演示，但列入近期改造计划（迁 IO + 分页）。
- 长文本与时间：消息 content 用 TEXT，不截断；时间戳用 Long。
- 分层：ViewModel 只依赖 Repository，Repository 屏蔽 DAO 细节，方便以后加缓存或换存储。



## 调试与可视化

- Debug 可打开 Room/SQLite 日志，或用 Android Studio Database Inspector 直接看表。
- 需要备份时，可在模拟器/开发设备用 Device Explorer 导出数据库文件。



## 后续计划

- 写 Migration 样板，预防下一次 schema 变更时“必须删库”的尴尬。
- 将所有 DAO 调用迁移到 IO 线程，并给历史/会话列表加分页，避免一次性加载大数据。
- 如面向生产，再补充本地加密与敏感字段脱敏。

