# DreamAIChat_APP 架构设计白皮书



## 1. 项目概述

### 1.1 项目信息
- **项目名称**: DreamAIChat_APP
- **APP名称**:Dream (即梦)
- **开发语言**: Java + Kotlin
- **架构模式**: MVI (Model-View-Intent)
- **目标平台**: Android 5.0+ (API 21+)
- **最低 SDK**: 21
- **目标 SDK**: 36

### 1.2 技术栈
- **UI框架**: XML布局 + ViewBinding
- **异步处理**: RxJava 3 + LiveData
- **网络层**: Retrofit 2 + OkHttp 3
- **数据持久化**: Room
- **架构模式**: MVVM（主流程）+ MVI（登录入口）
- **架构组件**: AndroidViewModel, LiveData, Lifecycle, RxJava Schedulers
- **UI组件**: Material Design Components



## 2. 架构设计

### 2.1 整体架构

项目采用**分层架构 + MVI模式**，确保代码的可维护性、可测试性和可扩展性。

```
┌─────────────────────────────────────────┐
│          UI Layer (Activities/Fragments)│
│         - 纯渲染组件，收集用户输入          │
└─────────────────┬───────────────────────┘
                  │
┌─────────────────▼───────────────────────┐
│      Presentation Layer (ViewModels)    │
│         - MVI模式：State/Intent/ViewModel│
│         - 状态管理和业务逻辑处理            │ 
└─────────────────┬───────────────────────┘
                  │
┌─────────────────▼───────────────────────┐
│         Domain Layer (Use Cases)        │
│         - 业务逻辑封装                    │
│         - 独立于框架，便于测试             │
└─────────────────┬───────────────────────┘
                  │
┌─────────────────▼───────────────────────┐
│         Data Layer (Repository)         │
│         - 统一数据源访问                  │
│         - 协调本地和远程数据               │
└─────────────────┬───────────────────────┘
                  │
        ┌─────────┴─────────┐
        │                   │
┌───────▼────────┐  ┌───────▼────────┐
│  Local Data    │  │  Remote Data   │
│  (Room)        │  │  (Retrofit)    │
└────────────────┘  └────────────────┘
```

### 2.2 架构模式：MVVM + MVI 协同

#### 2.2.1 为什么采用混合模式

- **登录入口** 需要明确的状态流转（Idle → Loading → Success/Error），继续沿用训练营早期提供的 `BaseViewModel` + Intent + State 模板最省心。
- **核心功能（聊天 / 历史 / 个人中心）** 在正式迭代中转向更贴近 Android 官方推荐的 **MVVM + LiveData** 写法，便于与 Room、ViewBinding、导航栈集成。
- 通过混合模式，可以在不破坏原有登录代码的前提下，逐步将业务迁移到更轻量的 MVVM 形态。

#### 2.2.2 MVVM（聊天 / 历史 / 个人中心）

- `ChatViewModel` / `HistoryViewModel` / `ProfileFragment` 等全部继承 `AndroidViewModel`，直接暴露 `LiveData` 给界面层。
- 单向数据流示意：
  ```
  用户交互 → Fragment → ViewModel（封装 UseCase / Repository） → LiveData<State>
                                                        ↓
                                                 Room/Retrofit
  ```
- 关键实践：
  - `MutableLiveData<List<ChatMessage>>` 驱动消息列表；
  - `MutableLiveData<Boolean>` 控制“AI 正在生成”动画；
  - 通过 `SessionManager` 持久化 Token、用户昵称等。

#### 2.2.3 MVI（登录模块）

- 登录仍由 `BaseViewModel`、`LoginIntent`、`LoginState` 组合驱动：
  ```
  Intent(Login / Register) → LoginViewModel → LoginUseCase → LoginState (Idle/Loading/Success/Error)
  ```
- 该模块对 RxJava 依赖最深（使用 `BehaviorSubject`、`CompositeDisposable` 管理状态流）。
- 由于登录只发生在启动阶段，保留 MVI 可以复用原先的状态机代码，同时避免大规模重构。

### 2.3 分层架构详解

#### 2.3.1 UI 层 (UI Layer)

**职责**:
- 渲染界面
- 收集用户输入
- 观察 State 并更新 UI

**组件**:
- `Activity`: 界面容器
- `Fragment`: 可复用的UI组件
- `XML Layout`: 界面布局
- `ViewBinding`: 类型安全的视图绑定

**特点**:
- 尽可能保持无状态
- 通过观察 State 更新 UI
- 用户交互转换为 Intent

#### 2.3.2 表现层 (Presentation Layer)

**职责**:
- 处理UI逻辑和状态管理
- 将 Intent 转换为业务操作
- 管理 State 的流转

**组件**:
- `ViewModel`: 继承 `BaseViewModel`
- `State`: 不可变的UI状态
- `Intent`: 用户意图

**示例**:

```java
public class LoginViewModel extends BaseViewModel<LoginState, LoginIntent> {
    @Override
    protected Observable<LoginState> processIntents(Observable<LoginIntent> intents) {
        return intents.flatMap(intent -> {
            if (intent instanceof LoginIntent.Login) {
                return handleLogin((LoginIntent.Login) intent);
            }
            return Observable.just(getCurrentState());
        });
    }
}
```

#### 2.3.3 领域层 (Domain Layer)

**职责**:
- 封装复杂业务规则
- 实现业务逻辑复用
- 独立于框架，便于测试

**组件**:
- `UseCase`: 业务用例类

**示例**:

```java
public class LoginUseCase {
    public Single<UserEntity> execute(String account, String password) {
        // 业务逻辑
        return apiService.login(request)
            .flatMap(response -> {
                // 处理响应
                return userRepository.insertOrUpdateUser(user);
            });
    }
}
```

#### 2.3.4 数据层 (Data Layer)

**职责**:
- 统一数据源访问
- 协调本地和远程数据
- 隐藏数据获取细节

**组件**:
- `Repository`: 数据仓库
- `DAO`: 数据访问对象
- `Entity`: 数据实体
- `ApiService`: 网络服务接口

**数据流**:

```
Repository → DAO (Room) → Database
         → ApiService (Retrofit) → Remote API
```

### 2.4 数据持久化

#### 2.4.1 Room 数据库

**实体 (Entity)**:
- `UserEntity`: 用户信息
- `ConversationEntity`: 会话信息
- `MessageEntity`: 消息信息

**数据访问对象 (DAO)**:
- `UserDao`: 用户数据访问
- `ConversationDao`: 会话数据访问
- `MessageDao`: 消息数据访问

**数据库**:
- `AppDatabase`: Room 数据库单例

#### 2.4.2 网络层

**Retrofit 配置**:

- Base URL: 可配置
- 日志拦截器: 开发环境启用
- RxJava 适配器: 支持响应式编程
- Gson 转换器: JSON 序列化/反序列化

**API 服务**:
- `ApiService`: 定义所有网络接口
- `RetrofitClient`: Retrofit 客户端单例

### 2.5 依赖管理

#### 2.5.1 依赖注入策略

- **构造器注入**: 用于领域层和基础设施层组件
- **ViewModel注入**: 通过 `ViewModelProvider.Factory` 管理
- **作用域控制**: 严格管理组件生命周期，避免内存泄漏

#### 2.5.2 依赖关系

```
ViewModel → UseCase → Repository → DAO/ApiService
```

每一层只依赖下一层，保持单向依赖。



## 3. 核心模块

### 3.1 登录模块

**流程**:
1. 用户输入账号密码
2. 创建 `LoginIntent.Login`
3. `LoginViewModel` 处理 Intent
4. `LoginUseCase` 执行登录逻辑
5. 更新 `LoginState`
6. UI 观察 State 并更新

**关键类**:
- `LoginActivity`: 登录界面
- `LoginViewModel`: 登录逻辑
- `LoginUseCase`: 登录业务逻辑
- `LoginState`: 登录状态

### 3.2 聊天模块

**功能**:
- 消息发送和接收
- 消息列表展示
- 消息状态管理

**关键类**:
- `ChatFragment`: 聊天界面
- `ChatViewModel`: 继承 `AndroidViewModel`，负责消息列表、附件队列、模型切换等逻辑
- `SendMessageUseCase`: 发送消息业务逻辑
- `GetMessagesUseCase`: 获取消息业务逻辑（Room + ConversationRepository）

### 3.3 历史模块

**功能**:
- 会话列表展示
- 会话搜索
- 会话管理（删除、收藏等）

**关键类**:
- `HistoryFragment`: 历史界面
- `HistoryViewModel`: 负责搜索、分组、刷新状态
- `GetConversationsUseCase`: 获取会话列表业务逻辑

### 3.4 个人中心模块

**功能**:
- 用户信息展示
- 数据统计
- 特色功能入口

**关键类**:
- `ProfileFragment`: 个人中心界面（直接读取 `SessionManager` + Room 统计）
- `AccountSettingsFragment`: 编辑昵称 / 注销账号



## 4. 设计原则

### 4.1 SOLID 原则

- **单一职责原则**: 每个类只负责一个功能
- **开闭原则**: 对扩展开放，对修改关闭
- **里氏替换原则**: 子类可以替换父类
- **接口隔离原则**: 使用多个专门的接口
- **依赖倒置原则**: 依赖抽象而非具体实现

### 4.2 其他原则

- **DRY (Don't Repeat Yourself)**: 避免代码重复
- **KISS (Keep It Simple, Stupid)**: 保持简单
- **YAGNI (You Aren't Gonna Need It)**: 不要过度设计



## 5. 最佳实践

### 5.1 错误处理

- 使用 RxJava 的 `onErrorReturn` 处理错误
- 在 State 中包含错误信息
- UI 层显示友好的错误提示

### 5.2 内存管理

- 使用 `CompositeDisposable` 管理订阅
- 在 `onDestroy` 中清理资源
- 避免持有 Context 引用

### 5.3 线程管理

- 网络请求在 IO 线程执行
- UI 更新在主线程执行
- 使用 RxJava 的 `observeOn` 和 `subscribeOn`

### 5.4 状态管理

- State 是不可变的
- 使用 `copyWith` 方法创建新状态
- 通过 `distinctUntilChanged` 避免重复更新



## 6. 扩展性设计

### 6.1 模块化

项目结构支持模块化扩展：
- 每个功能模块独立
- 可以轻松添加新功能
- 便于团队协作

### 6.2 可测试性

- 领域层独立于框架，易于单元测试
- ViewModel 可以独立测试
- Repository 可以 mock

### 6.3 可维护性

- 清晰的分层结构
- 统一的代码风格
- 完善的注释和文档



## 7. 项目文件结构

### 7.1 目录结构

```
app/src/main/java/com/example/dreamaichat_app/
├── mvi/                    # MVI 架构基础
│   ├── State.java
│   ├── Intent.java
│   ├── ViewState.java
│   └── BaseViewModel.java
├── data/                   # 数据层
│   ├── entity/            # 实体类
│   ├── dao/               # 数据访问对象
│   ├── database/          # 数据库
│   ├── repository/        # 数据仓库
│   └── remote/            # 网络层
├── domain/                 # 领域层
│   └── usecase/           # 业务用例
├── presentation/          # 表现层
│   └── login/             # 登录模块的 State/Intent/ViewModel
└── ui/                     # UI 层
    ├── login/             # 登录界面
    ├── main/              # 主界面
    ├── chat/              # 聊天界面
    ├── history/           # 历史界面
    └── profile/           # 个人中心界面
```

### 7.2 关键文件说明

**MVI 基础类**:
- `mvi/State.java`: State 接口
- `mvi/Intent.java`: Intent 接口
- `mvi/ViewState.java`: ViewState 接口
- `mvi/BaseViewModel.java`: MVI ViewModel 基类

**数据层**:
- `data/entity/`: 数据库实体（UserEntity, ConversationEntity, MessageEntity）
- `data/dao/`: 数据访问对象（UserDao, ConversationDao, MessageDao）
- `data/database/AppDatabase.java`: Room 数据库
- `data/repository/`: 数据仓库（UserRepository, ConversationRepository, MessageRepository）
- `data/remote/`: 网络层（RetrofitClient, ApiService, 数据模型）

**领域层**:
- `domain/usecase/`: 业务用例（LoginUseCase, SendMessageUseCase, GetMessagesUseCase, GetConversationsUseCase）

**表现层**:
- `presentation/login/`: 登录模块的 State、Intent、ViewModel

**UI 层**:
- `ui/login/LoginActivity.java`: 登录界面
- `ui/main/MainActivity.java`: 主界面（底部导航容器）
- `ui/chat/ChatFragment.java`: 聊天界面
- `ui/history/HistoryFragment.java`: 历史界面
- `ui/profile/ProfileFragment.java`: 个人中心界面



## 8. 总结

DreamAIChat_APP 项目采用 **MVI + 分层架构** 的设计模式，确保了：

1. **可维护性**: 清晰的分层结构，易于理解和修改
2. **可测试性**: 各层独立，便于单元测试
3. **可扩展性**: 模块化设计，易于添加新功能
4. **性能**: 使用 RxJava 进行异步处理，避免阻塞主线程
5. **用户体验**: 响应式设计，流畅的交互体验

